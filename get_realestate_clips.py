import argparse
import json
import os
import os.path as osp
from tqdm import tqdm
from moviepy import VideoFileClip
import imageio
from decord import VideoReader
import concurrent.futures
from functools import partial
import traceback


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('--video_root', required=True)
    parser.add_argument('--save_path', required=True)
    parser.add_argument('--video2clip_json', required=True, help='generated by gather_realestate.py')
    parser.add_argument('--clip_txt_path', required=True, help='path to the downloaded realestate txt files')
    parser.add_argument('--num_workers', type=int, default=4, help='number of parallel workers to extract clips')
    return parser.parse_args()


if __name__ == '__main__':
    args = get_args()
    os.makedirs(args.save_path, exist_ok=True)
    video2clips = json.load(open(args.video2clip_json, 'r'))
    video_names = list(video2clips.keys())
    video2clips = {k: v for k, v in video2clips.items() if k in video_names}

    def process_clip(video_root, clip_txt_path, save_path, video_name, clip):
        """Worker function to extract one clip. Returns (clip, success, message)."""
        try:
            clip_save_path = osp.join(save_path, video_name)
            os.makedirs(clip_save_path, exist_ok=True)
            clip_save_name = clip + '.mp4'
            out_path = osp.join(clip_save_path, clip_save_name)
            if osp.exists(out_path):
                return (clip, True, 'already_exists')

            video_path = osp.join(video_root, f"v={video_name}_successdownload")
            if not osp.exists(video_path):
                return (clip, False, f'video_missing:{video_path}')

            # open video per worker to avoid sharing handles between processes
            video = VideoFileClip(video_path)
            try:
                with open(osp.join(clip_txt_path, clip + '.txt'), 'r') as f:
                    lines = f.readlines()
                frames_lines = [x for x in lines[1: ]]
                if len(frames_lines) == 0:
                    return (clip, False, 'no_frames')
                timesteps = [int(x.split(' ')[0]) for x in frames_lines]
                if timesteps[-1] <= timesteps[0]:
                    return (clip, False, 'invalid_timesteps')
                timestamps_seconds = [x / 1000000.0 for x in timesteps]
                frames = [video.get_frame(t) for t in timestamps_seconds]
                imageio.mimsave(out_path, frames, fps=getattr(video, 'fps', 25))
            finally:
                try:
                    video.reader.close()
                    video.close()
                except Exception:
                    pass

            # verify frames count quickly using decord
            try:
                video_reader = VideoReader(out_path)
                if len(video_reader) != len(timesteps):
                    return (clip, False, f'frame_count_mismatch:{len(video_reader)}vs{len(timesteps)}')
            except Exception as e:
                return (clip, False, f'verify_failed:{str(e)}')

            return (clip, True, 'ok')
        except Exception as e:
            tb = traceback.format_exc()
            return (clip, False, f'exception:{str(e)}\n{tb}')

    # use ProcessPoolExecutor to parallelize clips across workers
    for video_name, clip_list in tqdm(video2clips.items()):
        video_path = osp.join(args.video_root, f"v={video_name}_successdownload")
        if not osp.exists(video_path):
            print(f"Video {video_path} does not exist. Skipping...")
            continue

        clip_save_path = osp.join(args.save_path, video_name)
        os.makedirs(clip_save_path, exist_ok=True)

        results = []
        with concurrent.futures.ProcessPoolExecutor(max_workers=args.num_workers) as exe:
            func = partial(process_clip, args.video_root, args.clip_txt_path, args.save_path, video_name)
            futures = {exe.submit(func, clip): clip for clip in clip_list}
            for fut in tqdm(concurrent.futures.as_completed(futures), total=len(futures)):
                clip = futures[fut]
                try:
                    res = fut.result()
                except Exception as e:
                    res = (clip, False, f'proc_exc:{str(e)}')
                results.append(res)

        # report summary for this video
        ok = sum(1 for _, s, _ in results if s)
        fail = len(results) - ok
        print(f"Video {video_name}: {ok} succeeded, {fail} failed ({len(results)} total)")
